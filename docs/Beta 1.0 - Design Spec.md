# Beta 1.0 - Design Spec

标签（空格分隔）： Sudoku

---

## **文档日志**

| 日期       | 备注       |
| ---------- | ---------- |
| 2017-09-07 | 设计文档初稿
| 2017-09-07 | 设计文档初稿审查


---

## **1. 具体输入 / 输出 / 边界**

- **Sample Input（命令行输入）**
```
sudoku.exe -c 20
```

- **Sample Output（输出到sudoku.txt）**
```
2 0 0 0 0 0 9 0 1
3 4 0 0 6 0 0 0 0
0 0 0 0 0 0 0 0 0
0 0 0 0 2 0 0 3 0
0 0 9 5 0 8 0 0 7
0 0 6 0 0 0 0 0 0
0 0 0 0 0 0 5 4 0
0 0 0 1 0 0 0 0 0
0 0 0 7 0 9 0 0 0
```

- **边界**

| Param | Type | Range |
| ----- | ---- | ----- |
| 生成个数 **`N`** | 数字 | **`[1, 1000000]`**


---

## 2. **具体语言 / 工具**

- **System**：**`Windows 10`**
- **Language**：**`C++`**
- **IDE**：**`Visual Studio 2017 Community`**

--- 

## 3. **具体终盘生成算法设计（拟定为 方案三）**

### **方案一：矩阵转换法**

- **详细资料：[《数独终盘生成的几种方法》][1]**
- **核心思想**：从一个初始终盘（**“种子”**），通过 **“交换行 / 列”**、 **“交换数字”** 等方法生成其余矩阵
- **具体方案**：**“交换行列”**、**“交换数字”**、**“旋转终盘”**、**“对角线对称”** 等。
- **优点 `速度较快`**：需要生成大量终盘的时候相当的高效。
- **缺点 `质量较差`**：同一 **“种子”** 生成的矩阵 **本质相同**，即 **“随机性”** 较差。
- **时间复杂度分析**：
 1. 假定已有种子，假定访问一遍棋盘的时间为 **`O(n)`**, 该算法的复杂度为 **`O(n)`** 级别。

### **方案二：随机法**

- **详细资料：**
 - **[《数独终盘生成的几种方法》][1]**
 - **[《基于“挖洞”思想的数独游戏生成算法》][2]**
- **核心思想**：终盘数量多达 **6.67×10^21**，能随机出来的概率很大。
- **优点 `质量较好`**：随机性较强。
- **缺点 `速度较慢`**：根据资料，平均约50次随机一维数组。而且大部分实例调用的次数在100以内
- **具体方案**：**`拉斯维加斯算法`** + **`回溯法`**
 - 第一行随机生成
 - 后续每行都不断随机生成直到合法
 - 防止超时，设置每次的阈值：220次后重置
- **复杂度分析**
 - 按平均50次估计，假设访问一篇棋盘的时间为 **`O(n)`**，据资料测试数据来看该算法的复杂度也是 **`O(n)`** 级别，但是常数大概是方案一的 6~10 倍。

### **方案三：方案一 + 方案二 的 折衷**

- **考虑背景**：
 - 由于是使用时现场生成，所以考虑到运行时间很大程度取决于用户的计算机计算性能而非开发者（开发者的计算机性能普遍较好）
 - 计算机性能较好时，若 **方案一** 运行的时间在 0.5s 内，此时 **方案二** 的耗时和方案一差别不大，质量较好，我们更倾向于方案二。
 - 计算机性能较差时，若 **方案一** 运行的时间超过了 10s，此时 **方案二** 的耗时就会变得难以接收（计时单位变成 分钟 ），我们更倾向于方案一。
- **具体方案** 
 - 用 **方案二生成部分种子**，其余的由 **方案一通过这些种子生成** 
 - 提供输入质量百分比 **p (range[0, 100])**，默认为 **50** ；
 - **p 为 0**时： **高性能** 模式，除了一个种子外完全采用方案一。
 - **p 为 100**时：**高质量** 模式，即直接生成足够数量的种子，完全采用方案二。
 - 运行时间 和 p 成正比。

---

## 4. **模块一 · Sudoku类**
| 成员列表  | 备注 |
| --------- | ---- |
| **`int matrix[9][9]`**   | 数独矩阵
| **`int crashNumber`**    | 矩阵中冲突的位置数量
| **`int usedRow[9][10]`** | **`usedRow[i][j]`** ：第 i 行，数字 j 被使用的次数
| **`int usedCol[9][10]`** | **`usedCol[i][j]`** ：第 i 列，数字 j 被使用的次数
| **`int usedBlock[3][3][10]`** | **`usedBlock[i][j][k]`**：**`(i, j)`** 宫中数字 k 被使用的次数


| 函数列表   | 备注 |
| ---------- | ---- |
| **`void swapRow(int rowA, int rowB)`** | 交换两行
| **`void swapCol(int colA, int colB)`** | 交换两列
| **`void Rotate(int rate)`**            | 顺时针旋转 **`rate * 90`** 度
| **`bool setRow(int rowId, int newRow[10])`** | 设置某行，成功时返回true
| **`bool noCrash()`**                   | 检测是否有冲突


---

## 5. **模块二 · Generator类**
| 函数列表 | 功能 |
| -------- | ---- |
| **`vector<Sudoku> QuicklyGenerate(Sudoku seed, int number)`** |  按给定的种子 **seed** 生成 **number** 个 **Sudoku**
| **`vector<Sudoku> BestGenerate(int number)`**                 |  按给定的种子 **seed** 生成 **number** 个 **Sudoku**
| **`vector<Sudoku> Generate(int number, int qualityRate)`**    | 按质量比进行任务分配





[1]: https://my.oschina.net/wangmengjun/blog/781984
[2]: https://wenku.baidu.com/view/f9e3f17101f69e31433294e1.html